Spring Cloud
	架构发展
		单体应用
		垂直应用（多tomcat）
		SOA服务
			分布式，面向服务编程
		微服务
			仅仅是拆分服务更加精细，不允许重复功能出现
	常规概念
		服务注册与发现
			注册中心
		负载均衡
		熔断保护
		链路追踪
		API网关
	eureka 注册中心
		AP
			保证高可用，分区容错性。 体现最终一致性
		eureka server
			服务启动
			集群间服务复制
				默认10分钟更新集群节点信息，或者当eureka client 请求注册，续约，下架 都会同步集群的其他节点
			自我保护
				15分钟之内超过85%的客户端节点没有正常心跳，eureka认为客户端与注册中心出现网络故障，进入自我保护
					假如有四个客户端，按正常30s进行心跳续约，eureka 一分钟会接受到 8 次续约请求。如果当前有一个服务挂掉，在一分钟内正常的心跳预约只有 6 次，低于正常情况的85% ，就会启用自我保护
			服务剔除
				默认60秒检测一次实例在一段时间没有心跳，就注销该实例
		eureka client
			服务注册
			服务续约（心跳检测）报活
				租约续约时间默认30s，租约到期时间90秒，也就是说允许三次重试去续约
			服务下架
			服务拉取
				每隔30秒会拉取一次服务列表，缓存到本地
				分为全量拉取，增量拉取应用实例  三级缓存（只读，读写，注册表） 计算 apphashcode
		问题
			为什么在集群模式下，客户端设置eureka注册中地址会把所有的eureka 地址都写上？
				虽然只写一个eureka地址，在集群模式下可以进行服务复制，但是如果客户端都注册到一个eureka上，当这个eureka宕机，会导致后续的client或者重启的client都无法正常注册到eureka服务中
			生产部署，怎么正确优化服务下线过程？
				https://www.cnblogs.com/yangzhilong/p/7161941.html
				手动执行服务下线操作，等客户端注册表缓存都失效后，再停止服务。
			生产实践，流水线中先摘除nginx流量，并从eureka取消注册，并等待缓存失效。再停止服务，并重启， 
				涉及nginx 中的check，check_http_send,check_http_expect_alive
	Ribbon 客户端负载均衡
		硬负载，软负载
			硬件负载，F5 软件负载 nginx
		服务端负载，客户端负载
			服务端负载均衡，指请求到达服务器服务端实现的负载均衡（F5,nginx）
			客户端负载均衡，指发起请求的客户端，根据服务端列表，实现一个负载均衡算法，选择一个服务端地址访问
		负载均衡算法
			默认 区域权衡策略
				扩展了轮询策略
			轮询策略
				所有服务实例，轮询获取，判读是否可用，如果10次内不可用，就返回null的server
			随机策略
				生成一个随机数，获取一个服务实例
			重试策略
				继承RoundRibbonRule 在500ms 重试找到可用的 server
			可用过滤策略
				扩展轮询策略，判断服务是否可用，服务是否连接数可用
			最小连接策略
				选择server连接数最少的
		可用性判断
			通过ping 机制来实现
	Hysitx 熔断器
		雪崩效应
			下游服务出现请求阻塞，大量的请求被阻塞，资源被消耗，导致上游服务崩溃，使得整个服务崩溃
			解决方案
				服务熔断
					当服务响应时间太长，或者不可用，熔断对该服务的访问，进行降级
				服务降级
					当服务进行熔断，执行服务降级，直接返回一个兜底数据，提供服务响应
				服务限流
					控制服务请求并发数
					常见算法
						令牌桶算法
							以恒定速率生成令牌（token）放入桶中，请求进入从桶中获得一个令牌，如果当前桶中没有令牌，则拒绝服务。有一定解决突发流量的能力
						漏桶算法
							大量请求（水）进入桶中，以恒定的速率从水桶中处理请求（流水），当请求超过桶容量溢出，可以拒绝服务
						为什么说令牌桶算法能解决一定程度的突发请求
							假定令牌桶大小100中每秒产生15个令牌，漏桶大小100中每秒处理15个请求。当现有10个请求触发，没有什么问题。突然请求增加，请求增加到30个每秒，令牌桶在令牌多的情况下，可以一次性处理完毕。漏桶还是以15个每秒进行处理
		线程池隔离
			仓壁模式
				默认为每个带hystrixcommand方法初始化一个线程池，线程数默认为10个
		扇入/扇出
			扇入服务指上游服务，扇出服务指下游服务
		服务监控
			单服务
			聚合服务
		跳闸机制和自我修复
			统计窗口
				在服务调用出现问题时，开启一个统计窗口（10s），判断在10s内请求是否达到最小请求数（默认值20次），比如说两个请求，没有达到，就撤销统计窗口。如果达到并且失败率在百分之50以上，就创建一个活动窗口，并跳闸，不允许再请求该服务
			活动窗口
				出现跳闸后，在活动窗口（5s）在5s后会释放一个请求。去调用服务，如果成功，就正常都触发请求。如果还是失败，继续跳闸，不允许服务被调用，再次创建一个活动窗口，依次往复
	Feign 远程调用组件
		集成了RestTemplate + Ribbon + hystrix
		问题
			微服务A通过Feign调用微服务B，微服务B出现了异常，返回的状态码不是 2XX 就会走服务降级，就会把服务降级的信息返回，我们希望微服务B有问题，在前端能正常看出是微服务B的错误
				推荐  方案1，微服务B 出现异常正常返回异常信息，类似于 data{code：xxx,msg:xx} 形式，不是修改http的响应状态
	Gateway网关
		webfilter过滤器
			全局过滤器GlobalFilter
				pre 前置过滤器，准备请求真实服务之前
				post 后置过滤器，服务响应的过滤和判断
			单个路由器过滤器 GateWayFilter
			常见过滤器
				跨域请求
				认证授权
				入口日志记录
				ip黑白名单
				限流
		GateWay高可用
			配合nginx高可用集群，配置多个gateway网关地址分发请求
		断言
			路径匹配
				匹配后分发
			请求头匹配
				比如校验请求头是否包含token参数
			cookie匹配
				校验cookie合法
		基于异步非阻塞框架提供路由转发功能 
		动态路由
			结合Eureka 配置为 lb://服务名称
		考虑的问题1：全局异常处理，当微服务程序出现异常，如何处理
	Spring cloud 服务常见问题
		eureka client注册服务后，消费者无感知一段时间才开始访问，erreka client 下线后，还有服务一直在访问导致报错
		服务超时时间设置
			spring cloud 中包含了各个组件，在服务调用过程中需要设置请求响应的超时时间，所以要关注 hystrix 和 ribbon 的超时时间设置，并且 hystrix 要比ribbon 超时时间设置长，因为hystrix 熔断降级是基于ribbon 服务的
		问题出现原因，一方面因为eureka client 默认每隔30秒拉取一次服务实例，ribbon默认每隔30秒从eureka client 同步现有的服务注册表。另一方面 eureka server 端存在两级缓存，一个是只读缓存，一个是读写缓存，只读缓存（currenthashmap）每隔30秒从读写缓存（guava cache）中获取注册表，而读写缓存每隔180s从真正的注册表中获取一次。
		解决方法，通过配置属性缩短eureka client 和 ribbon拉取服注册表时间，停用eureka server 的一级缓存或者设置一级缓存的失效时间更快
	重点源码
		eureka 
			服务注册 concurrentHashMap 读锁的使用
			服务增量获取    一级缓存（只读） 二级缓存（读写）  写锁的使用
			StringCache 的妙用
		ribbon
			各种客户端负载均衡策略
			thread.yeid
		hystrix
			rxjava
			线程池实现的舱壁模式
			切面
		feign
			java 动态代理实现
